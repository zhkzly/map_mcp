
"""
Plan Executor Tools for Agent-Based Plan Management and Execution (MCP/FastMCP)
================================================================================

This module provides a robust, agent-friendly set of tools for reading, executing, and updating task status in Markdown-based plans. All tools are exposed as MCP/FastMCP resources, with detailed docstrings and clear argument/return value documentation to support agent selection and orchestration.

Key Features:
-------------
* **Markdown Plan Parsing:** Extracts tasks, status, and IDs from Markdown files generated by compatible plan generators.
* **Task Status Management:** Allows agents to mark tasks as done, in progress, or todo, and persist these changes in Markdown.
* **Plan Execution Loop:** Supports agent-driven execution of all unfinished tasks, with status updates after execution.
* **Task Notes:** Enables agents to add notes/comments to specific tasks in the Markdown plan for traceability and collaboration.
* **File Path Resolution:** Provides tools to resolve and verify the file path for a given plan ID, ensuring compatibility with other modules.

Usage Scenarios:
----------------
* Agents can list all tasks in a plan, retrieve the next unfinished task, mark tasks as done/in progress/todo, and add notes to tasks.
* The closed-loop workflow supports: plan generation → Markdown persistence → agent execution/marking → status update, with all operations accessible as MCP tools.
* All tools are documented for unambiguous selection and orchestration by agent frameworks.

Arguments and Return Values:
---------------------------
* All tools specify their arguments and return values in the docstrings, including expected types and usage notes.
* Task status values are standardized as: 'todo', 'in_progress', 'done'.
* Markdown file format and workflow are fully compatible with plan_generator_tools.py and local_server.py.

This module is intended for use in agent-based, autonomous, or orchestrated environments where robust, transparent plan execution and status tracking are required.
"""

from mcp.server.fastmcp import FastMCP, Context
from typing import List, Dict, Any, Optional
import os

from client.config.config import Configuration


config=Configuration()
config.load_env()

settings = config.load_config(os.getenv("PLAN_EXECUTOR_CONFIG_PATH", "client/config/settings.json"))
mcp = FastMCP("PlanExecutor", settings=settings)

def parse_markdown_tasks(markdown_path: str) -> List[Dict[str, Any]]:
    """
    Parse all tasks from a Markdown plan file, extracting each task's unique ID, content, and status.
    
    Args:
        markdown_path (str): Absolute or relative path to the Markdown plan file.
    
    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a task with the following keys:
            - 'id' (str): Unique identifier for the task (from the `id:...` code block in the line).
            - 'content' (str): The human-readable description of the task.
            - 'status' (str): One of 'todo', 'in_progress', or 'done', based on the checkbox marker.
            - 'raw' (str): The raw Markdown line for the task.
    
    Notes:
        - Only lines starting with '- [ ]', '- [~]', or '- [x]' and containing an `id:...` code block are considered tasks.
        - This function is used internally by other tools to provide structured task data for agent workflows.
    """
    tasks = []
    if not os.path.exists(markdown_path):
        return tasks
    with open(markdown_path, 'r') as f:
        lines = f.readlines()
    for line in lines:
        line = line.strip()
        if line.startswith('- [') and '`id:' in line:
            status = 'todo'
            if line.startswith('- [x]'):
                status = 'done'
            elif line.startswith('- [~]'):
                status = 'in_progress'
            content = line.split('`id:')[0].split(']')[-1].strip()
            task_id = line.split('`id:')[1].split('`')[0]
            tasks.append({
                'id': task_id,
                'content': content,
                'status': status,
                'raw': line
            })
    return tasks

def update_task_status_in_markdown(markdown_path: str, task_id: str, new_status: str) -> bool:
    """
    Update the status marker (checkbox) of a specific task in a Markdown plan file.
    
    Args:
        markdown_path (str): Path to the Markdown plan file.
        task_id (str): Unique identifier of the task to update.
        new_status (str): New status for the task. Must be one of 'todo', 'in_progress', or 'done'.
            - 'todo' sets the marker to '- [ ]'
            - 'in_progress' sets the marker to '- [~]'
            - 'done' sets the marker to '- [x]'
    
    Returns:
        bool: True if the task was found and updated, False otherwise.
    
    Notes:
        - This function is used by agent tools to persist status changes after execution or review.
        - The update is atomic and only affects the first matching task with the given ID.
    """
    if not os.path.exists(markdown_path):
        return False
    with open(markdown_path, 'r') as f:
        lines = f.readlines()
    updated = False
    for i, line in enumerate(lines):
        if f'`id:{task_id}`' in line:
            if new_status == 'done':
                lines[i] = line.replace('- [ ]', '- [x]').replace('- [~]', '- [x]')
            elif new_status == 'in_progress':
                lines[i] = line.replace('- [ ]', '- [~]').replace('- [x]', '- [~]')
            else:
                lines[i] = line.replace('- [x]', '- [ ]').replace('- [~]', '- [ ]')
            updated = True
            break
    if updated:
        with open(markdown_path, 'w') as f:
            f.writelines(lines)
    return updated

@mcp.tool()
def list_markdown_tasks(ctx: Context, markdown_path: str) -> List[Dict[str, Any]]:
    """
    List all tasks in a Markdown plan file, returning their IDs, content, and status for agent processing.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        markdown_path (str): Path to the Markdown plan file.
    
    Returns:
        List[Dict[str, Any]]: List of all parsed tasks, each as a dictionary with 'id', 'content', 'status', and 'raw'.
    
    Usage:
        Use this tool to enumerate all tasks in a plan for display, reasoning, or batch processing by agents.
    """
    return parse_markdown_tasks(markdown_path)

@mcp.tool()
def get_next_unfinished_task(ctx: Context, markdown_path: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve the first unfinished task (status 'todo' or 'in_progress') from a Markdown plan file.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        markdown_path (str): Path to the Markdown plan file.
    
    Returns:
        Optional[Dict[str, Any]]: The first unfinished task as a dictionary (see list_markdown_tasks), or None if all tasks are done.
    
    Usage:
        Use this tool to implement stepwise or sequential agent execution, always working on the next available task.
    """
    tasks = parse_markdown_tasks(markdown_path)
    for task in tasks:
        if task['status'] != 'done':
            return task
    return None

@mcp.tool()
def mark_task_status(ctx: Context, markdown_path: str, task_id: str, status: str) -> bool:
    """
    Mark a specific task as 'done', 'in_progress', or 'todo' in a Markdown plan file.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        markdown_path (str): Path to the Markdown plan file.
        task_id (str): Unique identifier of the task to update.
        status (str): New status for the task. Must be one of 'done', 'in_progress', or 'todo'.
    
    Returns:
        bool: True if the task was found and updated, False otherwise.
    
    Usage:
        Use this tool to persistently update task status after agent execution, review, or correction.
    """
    return update_task_status_in_markdown(markdown_path, task_id, status)

@mcp.tool()
def execute_plan(ctx: Context, markdown_path: str) -> str:
    """
    Execute all unfinished tasks in a Markdown plan file, marking each as done after execution.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        markdown_path (str): Path to the Markdown plan file.
    
    Returns:
        str: A summary message indicating how many tasks were executed and marked as done.
    
    Notes:
        - This is a demonstration implementation: it marks all unfinished tasks as done without real execution logic.
        - Replace the internal logic with actual task execution as needed for your agent system.
    
    Usage:
        Use this tool for batch agent execution or to simulate plan completion in test environments.
    """
    tasks = parse_markdown_tasks(markdown_path)
    count = 0
    for task in tasks:
        if task['status'] != 'done':
            # Here you can call your real executor logic
            update_task_status_in_markdown(markdown_path, task['id'], 'done')
            count += 1
    return f"Executed and marked {count} tasks as done."

@mcp.tool()
def get_markdown_file_path(ctx: Context, plan_id: str) -> Dict[str, Any]:
    """
    Resolve and return the absolute file path for a Markdown plan file given its plan ID.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        plan_id (str): The unique identifier for the plan (used as the Markdown filename).
    
    Returns:
        Dict[str, Any]: Dictionary with the following keys:
            - 'plan_id' (str): The plan ID provided.
            - 'file_path' (str): Absolute path to the Markdown file.
            - 'exists' (bool): True if the file exists, False otherwise.
            - 'size_bytes' (int): File size in bytes (0 if file does not exist).
    
    Usage:
        Use this tool to locate, verify, or reference the Markdown file for a plan in agent workflows.
    """
    markdown_dir = "markdown_plans"
    file_path = f"{markdown_dir}/{plan_id}.md"
    return {
        "plan_id": plan_id,
        "file_path": os.path.abspath(file_path),
        "exists": os.path.exists(file_path),
        "size_bytes": os.path.getsize(file_path) if os.path.exists(file_path) else 0
    }

@mcp.tool()
def add_note_to_task(ctx: Context, markdown_path: str, task_id: str, note: str) -> bool:
    """
    Add a note or comment to a specific task in a Markdown plan file for traceability or collaboration.
    
    Args:
        ctx (Context): MCP context (injected by FastMCP, not used directly).
        markdown_path (str): Path to the Markdown plan file.
        task_id (str): Unique identifier of the task to which the note should be added.
        note (str): The note or comment to add (can be agent-generated or human-readable).
    
    Returns:
        bool: True if the note was added to the specified task, False if the task or file was not found.
    
    Usage:
        Use this tool to attach explanations, audit trails, or inter-agent messages to specific tasks in a plan.
    """
    if not os.path.exists(markdown_path):
        return False
    with open(markdown_path, 'r') as f:
        lines = f.readlines()
    for i, line in enumerate(lines):
        if f'`id:{task_id}`' in line:
            # Insert note after this line
            lines.insert(i+1, f"  - 💬 {note}\n")
            break
    with open(markdown_path, 'w') as f:
        f.writelines(lines)
    return True


def main():
    # 默认采用stdio 进行启动，另一个采用http启动
    mcp.run()
if __name__ == "__main__":
    main()